---
created: 2025-11-28T16:01
updated: 2025-11-28T16:26
---
## オーバーライド

### ◎ ざっくりイメージすると…

Character という「共通のインターフェイス」を持った生物がいて、  
“DamagePoints” という「攻撃の仕方」という振る舞いがある。

親はこう言うわけよ：

> 「攻撃っていう行為そのものは決まってるけど、  
> **具体的にどう攻撃するかは子どもたちで決めな**。」

これを C# 的にはこう書く：
```C#
//親クラス
public abstract int DamagePoints(Character target);

//子クラス
public override int DamagePoints(Character target)
{
    return target.Vulnerable() ? 10 : 6;
}
```

## 継承

### 親にフィールドを持たせるメリット
- 全クラスに共通する状態（HP、名前、位置など）をまとめられる
    
- 子クラスごとに状態を書く必要がなくなる（重複が消える）
    
- Character 型で扱えるようになり、共通のロジックが書ける
    
- 子クラスは振る舞い（攻撃ロジックなど）だけ override すればいい
- 
◆ 親クラス：Character
```C#
abstract class Character
{
    public int HP { get; protected set; }
    public string Name { get; }

    protected Character(string name, int hp)
    {
        Name = name;
        HP = hp;
    }

    public void TakeDamage(int amount)
    {
        HP -= amount;
        if (HP < 0) HP = 0;
    }

    public abstract int DamagePoints(Character target);
}

```

```C#
var w1 = new Warrior("Conan");
var w2 = new Wizard("Merlin");

// ウィザードが先に魔法を準備
w2.PrepareSpell();

// Conan が Merlin に攻撃される
int dmg = w2.DamagePoints(w1);
w1.TakeDamage(dmg);

Console.WriteLine($"{w1.Name} HP: {w1.HP}");


//結果
Conan HP: 100
```

