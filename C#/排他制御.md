---
created: 2025-11-10T15:55
updated: 2025-11-10T16:26
---
### 具体的な挙動を分解すると：

```C#
SemaphoreSlim.WaitAsync(int millisecondsTimeout, CancellationToken token)` 
```
 
は、「指定した時間だけロック取得を待つ」メソッド。

- 第1引数 `0` → 待ち時間ゼロ。つまり**即時判定**。
    
- ロックが空いていれば `true` を返してロック獲得。
    
- すでに送信中なら `false` を返す（＝スルー）。
    

だから実際のコード（`TryEnterSendAsync`）はこうなっている：
```C#
`private async Task<bool> TryEnterSendAsync(CancellationToken token)
 {     
		if (await _sendGate.WaitAsync(0, token).ConfigureAwait(false))
			 return true;      
		AddError("送信中です。");
		return false; }`
```

→ 他の送信（周期送信など）がまだ終わっていないときは、  
「送信中です」とUIに出して**待たずに即中止**。

---

## 🧠 じゃあ「待つ」ようにしたらどうなる？

もしこう書いたら：
```C#
await _sendGate.WaitAsync(token);
```
今度は「送信が終わるまで待つ」挙動になる。  
（つまり、先に送信中の処理が `_sendGate.Release()` を呼ぶまでブロック）

これでも動くけど、UI的にはちょっと良くない：

- 周期送信が走ってる間に「1回送信」ボタンを押したら固まる（ユーザーには“反応なし”に見える）
    
- 実際にはキャンセルも難しい（ロック待ち中はキャンセルしづらい）
    

だから `0` ミリ秒待ちで「送信中なら今は諦める」方がUI的にスマート。