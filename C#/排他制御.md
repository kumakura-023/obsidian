---
created: 2025-11-10T15:55
updated: 2025-11-10T16:26
---
### 具体的な挙動を分解すると：

```C#
SemaphoreSlim.WaitAsync(int millisecondsTimeout, CancellationToken token)` 
```
 
は、「指定した時間だけロック取得を待つ」メソッド。

- 第1引数 `0` → 待ち時間ゼロ。つまり**即時判定**。
    
- ロックが空いていれば `true` を返してロック獲得。
    
- すでに送信中なら `false` を返す（＝スルー）。
    

だから実際のコード（`TryEnterSendAsync`）はこうなっている：
```C#
`private async Task<bool> TryEnterSendAsync(CancellationToken token)
 {     
		if (await _sendGate.WaitAsync(0, token).ConfigureAwait(false))
			 return true;      
		AddError("送信中です。");
		return false; }`
```

→ 他の送信（周期送信など）がまだ終わっていないときは、  
「送信中です」とUIに出して**待たずに即中止**。

---

### 🧠 じゃあ「待つ」ようにしたらどうなる？

もしこう書いたら：
```C#
await _sendGate.WaitAsync(token);
```
今度は「送信が終わるまで待つ」挙動になる。  
（つまり、先に送信中の処理が `_sendGate.Release()` を呼ぶまでブロック）

これでも動くけど、UI的にはちょっと良くない：

- 周期送信が走ってる間に「1回送信」ボタンを押したら固まる（ユーザーには“反応なし”に見える）
    
- 実際にはキャンセルも難しい（ロック待ち中はキャンセルしづらい）
    

だから `0` ミリ秒待ちで「送信中なら今は諦める」方がUI的にスマート。

### 🧩 SemaphoreSlimとは？

### 一言で言うと

> **「一定数のスレッドしか同時に通さないための信号機」**

---

### 少し詳しく言うと

C# の `SemaphoreSlim` は「軽量なセマフォ（並列アクセス制御用オブジェクト）」で、  
「同時に○人まで入れる部屋」のような仕組みを提供するクラス。

`var gate = new SemaphoreSlim(1, 1);`

この例では、

- `1` = 一度に1つのタスクだけ通す
    
- つまり、**“排他ロック”と同じ動作**になる（でも`await`対応で非同期安全）
    

---

### 🔹 使い方（基本パターン）
```C#
await gate.WaitAsync();  // 入室（ロック取得） 
try {     // ここは同時に1タスクしか通れない     
		DoSomething(); 
	} 
finally {     
		gate.Release();  // 退室（ロック解放） 
		}
```
これで、

- `WaitAsync()` した人は「空きが出るまで待つ」
    
- `Release()` されるまで他の人は入れない  
    という仕組み。
    

---

### ⚙️ `_sendGate` の場合

`CommandViewModel` の中ではこう定義されている

CommandViewModel

：

`private readonly SemaphoreSlim _sendGate = new SemaphoreSlim(1, 1);`

つまり、

> 「送信処理は1回ずつしか走らせない」

という制御。  
これがあるおかげで、ユーザーがボタンを連打しても  
送信中にもう1つの送信処理が割り込まない。