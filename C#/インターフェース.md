---
created: 2025-11-14T13:57
updated: 2025-11-14T13:57
---
## ● 1) クラス分割だけでは「実装」に依存したまま

たとえば、インターフェースなしでこう書いたとする：

`public class TransmitterService {     private readonly SerialPortAdapter _port; // ←実装に依存！ }`

この時点で TransmitterService は **SerialPortAdapter を知ってしまっている**。

するとどうなる？

### ・FakePort を使いたい → 使えない

`public class FakePort { ... }`

TransmitterService は FakePort を受け取れない。  
型が SerialPortAdapter に固定されてるから。

### ・別のシリアル実装を使いたい → 差し替え不可

- System.IO.Ports の SerialPort
    
- USB仮想COMの独自ドライバ
    
- Raspberry Pi のUART  
    全部「型が違うから入れられない」。
    

### ●つまり…

**クラスを分けただけでは「依存の矢印」はそのまま実装へ刺さるまま。**

#" ● 2) インターフェースを挟むと矢印が“抽象”で止まる

`public class TransmitterService {     private readonly ISerialPort _port; // ← 抽象！ }`

ここで依存矢印が実装まで届かず、**抽象で止まる**。

FakePort も SerialPortAdapter も ISerialPort を実装してさえいれば挿せる。

依存関係がこうなる：
```C#
	`TransmitterService → ISerialP  ← SerialPortAdapter
									← FakePort
									← LoggingSerialPort
									← ReplayPort (ログ再生用)
```

完全に整う。  
差し替え自由、脳みそもスッキリ。

この“矢印の向き”の管理こそがインターフェースの本質。