---
created: 2025-11-14T13:57
updated: 2025-12-03T17:48
---
## ● 1) クラス分割だけでは「実装」に依存したまま

たとえば、インターフェースなしでこう書いたとする：

```C#
public class TransmitterService {     
	private readonly SerialPortAdapter _port; // ←実装に依存！ 
}
```

この時点で TransmitterService は **SerialPortAdapter を知ってしまっている**。
するとどうなる？
### ・FakePort を使いたい → 使えない

`public class FakePort { ... }`

TransmitterService は FakePort を受け取れない。  
型が SerialPortAdapter に固定されてるから。

### ・別のシリアル実装を使いたい → 差し替え不可

- System.IO.Ports の SerialPort
    
- USB仮想COMの独自ドライバ
    
- Raspberry Pi のUART  
    全部「型が違うから入れられない」。
    

### ●つまり…

**クラスを分けただけでは「依存の矢印」はそのまま実装へ刺さるまま。**

## ● 2) インターフェースを挟むと矢印が“抽象”で止まる

`public class TransmitterService {     private readonly ISerialPort _port; // ← 抽象！ }`

ここで依存矢印が実装まで届かず、**抽象で止まる**。

FakePort も SerialPortAdapter も ISerialPort を実装してさえいれば挿せる。

依存関係がこうなる：
```C#
	`TransmitterService → ISerialP  ← SerialPortAdapter
									← FakePort
									← LoggingSerialPort
									← ReplayPort (ログ再生用)
```

完全に整う。  
差し替え自由、脳みそもスッキリ。

この“矢印の向き”の管理こそがインターフェースの本質。

## ● 3) 「FakePortがあれば同じじゃない？」の落とし穴

FakePort を SerialPortAdapter と同じメソッド名で作ったとして、  
TransmitterService のコンストラクタはこうなってる：

`public TransmitterService(SerialPortAdapter port)`

FakePort は差し込めない。

**「型が違う」から。**

もし FakePort を SerialPortAdapter の継承にした場合は？

`public class FakePort : SerialPortAdapter { ... }`

### → それ、めっちゃ危険

- ありえないプロパティや機能まで全部継承される
    
- “挙動を上書きし忘れる”事故が起きる
    
- 実装の変更が FakePort に波及する（テスト壊れる）
    

要するに、**継承は Fake を作る方法として最悪**。

インターフェースは「最低限の契約だけ」なので副作用ゼロ。

## インターフェースのプロパティ

インターフェースのプロパティと実装側プロパティの違い
→[ChatGPT](https://chatgpt.com/g/g-p-692794b7083881918dd8e2622eb0000f-exercism/c/692ff7fb-30d0-8324-a18d-9ffdeee63f37)

