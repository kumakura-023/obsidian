---
created: 2025-11-10T14:58
updated: 2025-11-11T14:03
---

## ・ポートを開く
```C#
MainForm.cs内
//ボタンをクリックすると、"非同期"でイベントが発生
_openPortButton.Click += async (_, _) => await InvokeSafelyAsync(_viewModel.OpenPortAsync);


	await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	try
	{
		cancellationToken.ThrowIfCancellationRequested();
		SetConnectionState(PortConnectionState.Opening);
		try
		{
			if (_serialPort.IsOpen)
			{
				if (!string.Equals(settings.PortName, _serialPort.CurrentSettings?.PortName, StringComparison.OrdinalIgnoreCase))
				{
					_serialPort.Close();
					_serialPort.Open(settings);
				}
				else
				{
					_serialPort.UpdateSettings(settings);
				}
			}
			else
			{
				_serialPort.Open(settings);
			}
			SetConnectionState(PortConnectionState.Open);
			StatusMessage = "ポート " + settings.PortName + " を開きました。";
			return true;
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			SetConnectionState(PortConnectionState.Faulted);
			StatusMessage = "ポートを開く際にエラーが発生しました: " + ex2.Message;
			return false;
		}
	}
	finally
	{
		_connectionGate.Release();
	}
}
```

```C#
await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
```

### cancellationToken

C# の非同期処理の中で「**外から中断を伝えるための仕組み**」

#### ⚙️ 2. どう使うか（登場人物）

ふつうセットで使う：
```C#
var cts = new CancellationTokenSource();   // “発信機”
CancellationToken token = cts.Token;       // “信号線”
```

- `cts.Cancel()` を呼ぶと、`token` に「キャンセルされた！」というフラグが立つ。
    
- 処理の中ではそれを監視して、キャンセルされたら早めに抜ける。

### 🧠 3. メソッド内での使い方

`OpenPortAsync(CancellationToken cancellationToken)` の中でよく見る書き方はこんな感じ
```C#
cancellationToken.ThrowIfCancellationRequested();  await connectionGate.WaitAsync(cancellationToken).ConfigureAwait(false);`
```

これの意味を分解すると：

1. `ThrowIfCancellationRequested()`  
    → 呼ばれた時点でキャンセルされてたら、すぐ `OperationCanceledException` を投げて抜ける。  
    （try/catch の外までエラーを上げて止まる）
    
2. `WaitAsync(cancellationToken)`  
    → `_connectionGate.WaitAsync()` の待機中もキャンセル信号を監視していて、  
    キャンセルされたら途中で抜ける。

例：ウィンドウを閉じた時に、キャンセル信号を出す。

```C#
public ProgressForm()
    {
        InitializeComponent();
        this.FormClosing += (_, _) => _cts.Cancel(); // ← ウィンドウ閉じたらキャンセル
    }
```

### ConfigureAwait(continueOnCapturedContext: false);

`ConfigureAwait(false)` をつけると：(continueOnCapturedContext: false)はfalseを明示的にしてる。)

>「await のあとに、**元のスレッド（UIスレッド）に戻らず、スレッドプールのどこかで続きの処理をしていい**」
### 👀 つまり何のために使うか

####  **UIスレッドに戻る必要がないバックエンド処理**

たとえばポートを開く、ファイルを読む、CRCを計算するなど、  
UIと関係ない部分は `ConfigureAwait(false)` を付けると効率がいい。

理由：

- 戻るために `SynchronizationContext` のキャプチャ・復元が不要（わずかなコスト減）
    
- サーバー／非UI環境では、UIスレッドがないため戻ろうとしても無駄


## 送信

```C#
public async Task<bool> SendOnceAsync(CancellationToken cancellationToken)
{
    cancellationToken.ThrowIfCancellationRequested();

    if (!EnsurePortReadyForSend())
        return false;

    if (!(await TryEnterSendAsync(cancellationToken).ConfigureAwait(false)))
        return false;

    try
    {
        return await SendCoreAsync(isPeriodic: false, cancellationToken)
                     .ConfigureAwait(false);
    }
    finally
    {
        ExitSend();
    }
}
```

### 🧠 解説

1. **キャンセルチェック**  
    `cancellationToken.ThrowIfCancellationRequested()` により、外部からキャンセル指示が来ていたらすぐ終了。
    
2. **ポート状態確認**  
    `EnsurePortReadyForSend()` は、シリアルポートが開いていて送信可能な状態かを検査。  
    開かれていなければ `false` を返して終了し、UIに「ポートを開いてから送信してください」とメッセージを出す。
    
3. **排他制御 (`TryEnterSendAsync`)**  
    `_sendGate`（`SemaphoreSlim`）を使って送信処理の同時実行を防ぐ。  
    他の送信が走っている場合は待たずに `false` を返す。
    [[]]
4. **送信処理の本体 (`SendCoreAsync`)**  
    実際のフレーム組み立て、CRC計算、UART送信、レスポンス待機などを担当する非同期メソッド。  
    `isPeriodic: false` が指定されており、周期送信モードではなく単発送信。
    
5. **finallyブロックでリセット**  
    `ExitSend()` により `_sendGate.Release()` が呼ばれ、次の送信ができるようにロックを解放。

## ポートの監視
