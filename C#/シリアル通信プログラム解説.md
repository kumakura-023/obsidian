---
created: 2025-11-10T14:58
updated: 2025-11-12T16:18
---

## ・ポートを開く
```C#
MainForm.cs内
//ボタンをクリックすると、"非同期"でイベントが発生
_openPortButton.Click += async (_, _) => await InvokeSafelyAsync(_viewModel.OpenPortAsync);


	await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	try
	{
		cancellationToken.ThrowIfCancellationRequested();
		SetConnectionState(PortConnectionState.Opening);
		try
		{
			if (_serialPort.IsOpen)
			{
				if (!string.Equals(settings.PortName, _serialPort.CurrentSettings?.PortName, StringComparison.OrdinalIgnoreCase))
				{
					_serialPort.Close();
					_serialPort.Open(settings);
				}
				else
				{
					_serialPort.UpdateSettings(settings);
				}
			}
			else
			{
				_serialPort.Open(settings);
			}
			SetConnectionState(PortConnectionState.Open);
			StatusMessage = "ポート " + settings.PortName + " を開きました。";
			return true;
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			SetConnectionState(PortConnectionState.Faulted);
			StatusMessage = "ポートを開く際にエラーが発生しました: " + ex2.Message;
			return false;
		}
	}
	finally
	{
		_connectionGate.Release();
	}
}
```

```C#
await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
```

### cancellationToken

C# の非同期処理の中で「**外から中断を伝えるための仕組み**」

#### ⚙️ 2. どう使うか（登場人物）

ふつうセットで使う：
```C#
var cts = new CancellationTokenSource();   // “発信機”
CancellationToken token = cts.Token;       // “信号線”
```

- `cts.Cancel()` を呼ぶと、`token` に「キャンセルされた！」というフラグが立つ。
    
- 処理の中ではそれを監視して、キャンセルされたら早めに抜ける。

### 🧠 3. メソッド内での使い方

`OpenPortAsync(CancellationToken cancellationToken)` の中でよく見る書き方はこんな感じ
```C#
cancellationToken.ThrowIfCancellationRequested();  await connectionGate.WaitAsync(cancellationToken).ConfigureAwait(false);`
```

これの意味を分解すると：

1. `ThrowIfCancellationRequested()`  
    → 呼ばれた時点でキャンセルされてたら、すぐ `OperationCanceledException` を投げて抜ける。  
    （try/catch の外までエラーを上げて止まる）
    
2. `WaitAsync(cancellationToken)`  
    → `_connectionGate.WaitAsync()` の待機中もキャンセル信号を監視していて、  
    キャンセルされたら途中で抜ける。

例：ウィンドウを閉じた時に、キャンセル信号を出す。

```C#
public ProgressForm()
    {
        InitializeComponent();
        this.FormClosing += (_, _) => _cts.Cancel(); // ← ウィンドウ閉じたらキャンセル
    }
```

### ConfigureAwait(continueOnCapturedContext: false);

`ConfigureAwait(false)` をつけると：(continueOnCapturedContext: false)はfalseを明示的にしてる。)

>「await のあとに、**元のスレッド（UIスレッド）に戻らず、スレッドプールのどこかで続きの処理をしていい**」
### 👀 つまり何のために使うか

####  **UIスレッドに戻る必要がないバックエンド処理**

たとえばポートを開く、ファイルを読む、CRCを計算するなど、  
UIと関係ない部分は `ConfigureAwait(false)` を付けると効率がいい。

理由：

- 戻るために `SynchronizationContext` のキャプチャ・復元が不要（わずかなコスト減）
    
- サーバー／非UI環境では、UIスレッドがないため戻ろうとしても無駄


### 送信

```C#
public async Task<bool> SendOnceAsync(CancellationToken cancellationToken)
{
    cancellationToken.ThrowIfCancellationRequested();

    if (!EnsurePortReadyForSend())
        return false;

    if (!(await TryEnterSendAsync(cancellationToken).ConfigureAwait(false)))
        return false;

    try
    {
        return await SendCoreAsync(isPeriodic: false, cancellationToken)
                     .ConfigureAwait(false);
    }
    finally
    {
        ExitSend();
    }
}
```

### 🧠 解説

1. **キャンセルチェック**  
    `cancellationToken.ThrowIfCancellationRequested()` により、外部からキャンセル指示が来ていたらすぐ終了。
    
2. **ポート状態確認**  
    `EnsurePortReadyForSend()` は、シリアルポートが開いていて送信可能な状態かを検査。  
    開かれていなければ `false` を返して終了し、UIに「ポートを開いてから送信してください」とメッセージを出す。
    
3. **排他制御 (`TryEnterSendAsync`)**  
    `_sendGate`（`SemaphoreSlim`）を使って送信処理の同時実行を防ぐ。  
    他の送信が走っている場合は待たずに `false` を返す。
    [[]]
4. **送信処理の本体 (`SendCoreAsync`)**  
    実際のフレーム組み立て、CRC計算、UART送信、レスポンス待機などを担当する非同期メソッド。  
    `isPeriodic: false` が指定されており、周期送信モードではなく単発送信。
    
5. **finallyブロックでリセット**  
    `ExitSend()` により `_sendGate.Release()` が呼ばれ、次の送信ができるようにロックを解放。

## ・ポートの監視

### ① **監視の周期（ポーリング間隔）を決める**

```C#
`_pollInterval = (pollInterval is { } t && t > TimeSpan.Zero) ? t : TimeSpan.FromSeconds(2);`
```

- `pollInterval` はコンストラクタの引数。外から「何秒おきにチェックするか」を渡せるようになってる。
    
- でも渡されない場合（`null`）や、0以下の値が渡された場合は**安全なデフォルト**として2秒を使う。
    

中身を噛み砕くとこう：
```C#
if (pollInterval is { } t && t > TimeSpan.Zero)
_pollInterval = t; // 有効な値が渡された → それを使う
else     
_pollInterval = TimeSpan.FromSeconds(2); // 無効 or null → 2秒周期
````

ここで使われてる構文：

- `pollInterval is { } t` は「nullじゃなければ t に代入」という**パターンマッチ構文**。
    
- `&& t > TimeSpan.Zero` は「しかも0より大きいか？」というチェック。
    

---

### ② **タイマーを起動**して、「定期的にポート一覧を再取得する」

```C#
_timer = new System.Threading.Timer(OnTimer, null, _pollInterval, _pollInterval);
```

解説：

- `System.Threading.Timer` は「一定間隔でメソッドを呼ぶ」タイマー。
    
- 第一引数 `OnTimer` は**タイマーが鳴るたびに実行するメソッド**（コールバック）。
    
- 第二引数 `null` はコールバックに渡す追加データ（今回は不要だからnull）。
    
- 第三引数 `_pollInterval` は**最初の呼び出しまでの待ち時間**。
    
- 第四引数 `_pollInterval` は**繰り返しの間隔**。
    

つまりこの1行で：

> “プログラム起動後 `_pollInterval` 秒ごとに OnTimer() が呼ばれる”  
> という自動監視ループをセットしている。

---

### ③ **最初の1回だけ、手動でポート一覧を読み取る**

```C#
_ = RefreshAsync(CancellationToken.None);
```

- `_ = ...` は「戻り値を使わない」という意味。
    
    - `RefreshAsync()` は `Task` を返すけど、ここでは結果を待たずに“火をつけるだけ”。
        
- `CancellationToken.None` は「キャンセルされないトークン」。  
    つまり“普通に最後までやってOK”という指定。
    
中身の `RefreshAsync()` は：
```C#
public Task RefreshAsync(...) {     
	latest = SerialPort.GetPortNames();     
	比較して変化があれば PortsChanged イベントを発火; 
}
```

だから、**アプリ起動直後に一度だけ最新のポート一覧を取得**して、  
初期状態を整えているわけ。

### ポート一覧の取得と比較
```C#
 public Task RefreshAsync(CancellationToken cancellationToken = default)
 {
     cancellationToken.ThrowIfCancellationRequested();
     string[] latest;
     try
     {
         latest = SerialPort.GetPortNames()
             .OrderBy(p => p, StringComparer.OrdinalIgnoreCase)
             .ToArray();
     }
     catch
     {
         // 取得に失敗した場合は無視（デザインモードや権限不足等）
         latest = Array.Empty<string>();
     }

     bool changed = false;
     lock (_gate)
     {
         if (!_ports.SequenceEqual(latest, StringComparer.OrdinalIgnoreCase))
         {
             _ports = latest;
             changed = true;
         }
     }

     if (changed)
     {
         PortsChanged?.Invoke(this, GetCurrentPorts());
     }

     return Task.CompletedTask;
 }
```

ここでやってるのは：

1. OSから現在のポート名一覧を取得（`SerialPort.GetPortNames()`）
    
2. ソートして確定順序をつける
	
3. もし取得に失敗した（デザインモードなど）ら空配列にする
	
4. `_ports` に保存しておいた前回結果と新しい `latest` を比較。
	
5.  違いがあったら `_ports` を更新し、イベント `PortsChanged` を発火。
	
6. 上位（たとえばUIのCOMポート選択ドロップダウン）がここを購読していれば、自動的に更新できる。
### 🔹 タイマーの処理と破棄

```C#
`private void OnTimer(object? state) {
	if (_disposed) return;     
	try { _ = RefreshAsync(CancellationToken.None); }
	catch { /* 無視 */ } 
}
public void Dispose() {
	if (_disposed) return;
	_disposed = true;
	_timer.Dispose(); 
}`
```

- `_timer` が定期的に `OnTimer()` を呼ぶ。
    
- `Dispose()` が呼ばれると `_timer` を止めて終了。
    
- `IDisposable` 実装でタイマーを安全に解放。


## 送信

## 🧩 1. C# におけるシリアル通信の基本構造

.NETでは、シリアル通信の中核は `System.IO.Ports.SerialPort` クラス。  
このプロジェクトでは、それを抽象化した `ISerialPort` インターフェースを経由して使っている。

基本的な流れはどのモードも同じ：
```
Open(port settings) 
↓ 
Write(bytes to send) 
↓ 
Flush()
↓ 
Read() で応答取得 or バッファ監視
↓ 
Close()
```

ただし同期I/Oを直接使うとUIが固まるから、すべて非同期 (`await`) ベースで構築してある。  
`ISerialPort` の実装は `WriteAsync()`, `ReadAsync()`, `FlushAsync()` で `Task` を返す構造だ。

### 🧠 フレーム送信

```C#
await _serialPort.WriteAsync(bytesSnapshot, cancellationToken);
await _serialPort.FlushAsync(cancellationToken);
```
1. 送るデータは構造化済み `Frame73`
    
    - 73ワード（Sync, Gimbal, Infrared, CRC）
        
    - CRC16で誤り検出
        
    - 各ワードをリトルエンディアンで2byte化
        
2. 送信後に `_clock.DelayAsync()` で「最小送信間隔（14ms）」を確保  
    → 機器側が処理を終える前に次フレームを投げないようにする。
    
3. `TransmissionResult` に成否・時刻・CRC・試行回数を記録
    
4. ACK再送なども `AckOptions` / `IAckRetryCoordinator` で対応できる設計。
    

これは**ハードウェア寄りの制御通信（バイナリプロトコル)**に強い設計。  
1bitでもズレたら無効扱いにするような「堅牢プロトコル」に向いている。

### 💬 文字列送信

```C#
//改行チェックボックスを確認。
string payload = request.AppendLineFeed ? request.Payload + "\r\n" : request.Payload;

byte[] payloadBytes;
try
{
    payloadBytes = encoding.GetBytes(payload);
}
catch (EncoderFallbackException ex)
{
    TimeSpan failureDuration = _clock.UtcNow - startedAt;
    return StringSendResult.CreateFailure(
        failureDuration,
        "指定した文字列を選択した文字コードでエンコードできませんでした: " + ex.Message);
}

await _serialPort.WriteAsync(payloadBytes, cancellationToken).ConfigureAwait(false);
```

## 🧠 意味を分解すると

1. **`request.Payload`**  
    ユーザーがUI（`StringSendTabControl`）のテキストボックスに入力した文字列。  
    例: `"HELLO"` または `"AT+INFO"` など。
    
2. **`AppendLineFeed`**  
    チェックボックスがONなら、改行を末尾に付ける。  
    → `"HELLO\r\n"`
    
3. **`encoding.GetBytes(payload)`**  
    指定された文字コード（UTF-8 / Shift_JIS など）で文字列を**バイト列に変換**する。  
    これが `payloadBytes`。
    
    例えば：
    
    |payload|Encoding|payloadBytes の内容（16進表示）|
    |---|---|---|
    |`"HELLO"`|UTF-8|`48 45 4C 4C 4F`|
    |`"こんにちは"`|UTF-8|`E3 81 93 E3 82 93 E3 81 AB E3 81 A1 E3 81 AF`|
    |`"HELLO"`|Shift_JIS|`48 45 4C 4C 4F`（同じ）|
    |`"テスト"`|Shift_JIS|`83 65 83 58 83 67`|
    
    文字コードによって生成されるバイトパターンが違う。  
    機器側がどの文字コードを期待しているかに合わせる。
    
4. **`await _serialPort.WriteAsync(payloadBytes, cancellationToken)`**  
    そのバイト配列を、シリアルポートに非同期で書き込む。  
    実際に送信線（TX）に流れるのはこの `payloadBytes` の内容。