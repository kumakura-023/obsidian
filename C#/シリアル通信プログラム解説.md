---
created: 2025-11-10T14:58
updated: 2025-11-12T16:13
---

## ãƒ»ãƒãƒ¼ãƒˆã‚’é–‹ã
```C#
MainForm.cså†…
//ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€"éåŒæœŸ"ã§ã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿ
_openPortButton.Click += async (_, _) => await InvokeSafelyAsync(_viewModel.OpenPortAsync);


	await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	try
	{
		cancellationToken.ThrowIfCancellationRequested();
		SetConnectionState(PortConnectionState.Opening);
		try
		{
			if (_serialPort.IsOpen)
			{
				if (!string.Equals(settings.PortName, _serialPort.CurrentSettings?.PortName, StringComparison.OrdinalIgnoreCase))
				{
					_serialPort.Close();
					_serialPort.Open(settings);
				}
				else
				{
					_serialPort.UpdateSettings(settings);
				}
			}
			else
			{
				_serialPort.Open(settings);
			}
			SetConnectionState(PortConnectionState.Open);
			StatusMessage = "ãƒãƒ¼ãƒˆ " + settings.PortName + " ã‚’é–‹ãã¾ã—ãŸã€‚";
			return true;
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			SetConnectionState(PortConnectionState.Faulted);
			StatusMessage = "ãƒãƒ¼ãƒˆã‚’é–‹ãéš›ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + ex2.Message;
			return false;
		}
	}
	finally
	{
		_connectionGate.Release();
	}
}
```

```C#
await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
```

### cancellationToken

C# ã®éåŒæœŸå‡¦ç†ã®ä¸­ã§ã€Œ**å¤–ã‹ã‚‰ä¸­æ–­ã‚’ä¼ãˆã‚‹ãŸã‚ã®ä»•çµ„ã¿**ã€

#### âš™ï¸ 2. ã©ã†ä½¿ã†ã‹ï¼ˆç™»å ´äººç‰©ï¼‰

ãµã¤ã†ã‚»ãƒƒãƒˆã§ä½¿ã†ï¼š
```C#
var cts = new CancellationTokenSource();   // â€œç™ºä¿¡æ©Ÿâ€
CancellationToken token = cts.Token;       // â€œä¿¡å·ç·šâ€
```

- `cts.Cancel()` ã‚’å‘¼ã¶ã¨ã€`token` ã«ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸï¼ã€ã¨ã„ã†ãƒ•ãƒ©ã‚°ãŒç«‹ã¤ã€‚
    
- å‡¦ç†ã®ä¸­ã§ã¯ãã‚Œã‚’ç›£è¦–ã—ã¦ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‚‰æ—©ã‚ã«æŠœã‘ã‚‹ã€‚

### ğŸ§  3. ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã®ä½¿ã„æ–¹

`OpenPortAsync(CancellationToken cancellationToken)` ã®ä¸­ã§ã‚ˆãè¦‹ã‚‹æ›¸ãæ–¹ã¯ã“ã‚“ãªæ„Ÿã˜
```C#
cancellationToken.ThrowIfCancellationRequested();  await connectionGate.WaitAsync(cancellationToken).ConfigureAwait(false);`
```

ã“ã‚Œã®æ„å‘³ã‚’åˆ†è§£ã™ã‚‹ã¨ï¼š

1. `ThrowIfCancellationRequested()`  
    â†’ å‘¼ã°ã‚ŒãŸæ™‚ç‚¹ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¦ãŸã‚‰ã€ã™ã `OperationCanceledException` ã‚’æŠ•ã’ã¦æŠœã‘ã‚‹ã€‚  
    ï¼ˆtry/catch ã®å¤–ã¾ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¸Šã’ã¦æ­¢ã¾ã‚‹ï¼‰
    
2. `WaitAsync(cancellationToken)`  
    â†’ `_connectionGate.WaitAsync()` ã®å¾…æ©Ÿä¸­ã‚‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¿¡å·ã‚’ç›£è¦–ã—ã¦ã„ã¦ã€  
    ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‚‰é€”ä¸­ã§æŠœã‘ã‚‹ã€‚

ä¾‹ï¼šã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ãŸæ™‚ã«ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¿¡å·ã‚’å‡ºã™ã€‚

```C#
public ProgressForm()
    {
        InitializeComponent();
        this.FormClosing += (_, _) => _cts.Cancel(); // â† ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é–‰ã˜ãŸã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    }
```

### ConfigureAwait(continueOnCapturedContext: false);

`ConfigureAwait(false)` ã‚’ã¤ã‘ã‚‹ã¨ï¼š(continueOnCapturedContext: false)ã¯falseã‚’æ˜ç¤ºçš„ã«ã—ã¦ã‚‹ã€‚)

>ã€Œawait ã®ã‚ã¨ã«ã€**å…ƒã®ã‚¹ãƒ¬ãƒƒãƒ‰ï¼ˆUIã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰ã«æˆ»ã‚‰ãšã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã®ã©ã“ã‹ã§ç¶šãã®å‡¦ç†ã‚’ã—ã¦ã„ã„**ã€
### ğŸ‘€ ã¤ã¾ã‚Šä½•ã®ãŸã‚ã«ä½¿ã†ã‹

####  **UIã‚¹ãƒ¬ãƒƒãƒ‰ã«æˆ»ã‚‹å¿…è¦ãŒãªã„ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å‡¦ç†**

ãŸã¨ãˆã°ãƒãƒ¼ãƒˆã‚’é–‹ãã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€ã€CRCã‚’è¨ˆç®—ã™ã‚‹ãªã©ã€  
UIã¨é–¢ä¿‚ãªã„éƒ¨åˆ†ã¯ `ConfigureAwait(false)` ã‚’ä»˜ã‘ã‚‹ã¨åŠ¹ç‡ãŒã„ã„ã€‚

ç†ç”±ï¼š

- æˆ»ã‚‹ãŸã‚ã« `SynchronizationContext` ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ»å¾©å…ƒãŒä¸è¦ï¼ˆã‚ãšã‹ãªã‚³ã‚¹ãƒˆæ¸›ï¼‰
    
- ã‚µãƒ¼ãƒãƒ¼ï¼éUIç’°å¢ƒã§ã¯ã€UIã‚¹ãƒ¬ãƒƒãƒ‰ãŒãªã„ãŸã‚æˆ»ã‚ã†ã¨ã—ã¦ã‚‚ç„¡é§„


### é€ä¿¡

```C#
public async Task<bool> SendOnceAsync(CancellationToken cancellationToken)
{
    cancellationToken.ThrowIfCancellationRequested();

    if (!EnsurePortReadyForSend())
        return false;

    if (!(await TryEnterSendAsync(cancellationToken).ConfigureAwait(false)))
        return false;

    try
    {
        return await SendCoreAsync(isPeriodic: false, cancellationToken)
                     .ConfigureAwait(false);
    }
    finally
    {
        ExitSend();
    }
}
```

### ğŸ§  è§£èª¬

1. **ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒã‚§ãƒƒã‚¯**  
    `cancellationToken.ThrowIfCancellationRequested()` ã«ã‚ˆã‚Šã€å¤–éƒ¨ã‹ã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«æŒ‡ç¤ºãŒæ¥ã¦ã„ãŸã‚‰ã™ãçµ‚äº†ã€‚
    
2. **ãƒãƒ¼ãƒˆçŠ¶æ…‹ç¢ºèª**  
    `EnsurePortReadyForSend()` ã¯ã€ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆãŒé–‹ã„ã¦ã„ã¦é€ä¿¡å¯èƒ½ãªçŠ¶æ…‹ã‹ã‚’æ¤œæŸ»ã€‚  
    é–‹ã‹ã‚Œã¦ã„ãªã‘ã‚Œã° `false` ã‚’è¿”ã—ã¦çµ‚äº†ã—ã€UIã«ã€Œãƒãƒ¼ãƒˆã‚’é–‹ã„ã¦ã‹ã‚‰é€ä¿¡ã—ã¦ãã ã•ã„ã€ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºã™ã€‚
    
3. **æ’ä»–åˆ¶å¾¡ (`TryEnterSendAsync`)**  
    `_sendGate`ï¼ˆ`SemaphoreSlim`ï¼‰ã‚’ä½¿ã£ã¦é€ä¿¡å‡¦ç†ã®åŒæ™‚å®Ÿè¡Œã‚’é˜²ãã€‚  
    ä»–ã®é€ä¿¡ãŒèµ°ã£ã¦ã„ã‚‹å ´åˆã¯å¾…ãŸãšã« `false` ã‚’è¿”ã™ã€‚
    [[]]
4. **é€ä¿¡å‡¦ç†ã®æœ¬ä½“ (`SendCoreAsync`)**  
    å®Ÿéš›ã®ãƒ•ãƒ¬ãƒ¼ãƒ çµ„ã¿ç«‹ã¦ã€CRCè¨ˆç®—ã€UARTé€ä¿¡ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¾…æ©Ÿãªã©ã‚’æ‹…å½“ã™ã‚‹éåŒæœŸãƒ¡ã‚½ãƒƒãƒ‰ã€‚  
    `isPeriodic: false` ãŒæŒ‡å®šã•ã‚Œã¦ãŠã‚Šã€å‘¨æœŸé€ä¿¡ãƒ¢ãƒ¼ãƒ‰ã§ã¯ãªãå˜ç™ºé€ä¿¡ã€‚
    
5. **finallyãƒ–ãƒ­ãƒƒã‚¯ã§ãƒªã‚»ãƒƒãƒˆ**  
    `ExitSend()` ã«ã‚ˆã‚Š `_sendGate.Release()` ãŒå‘¼ã°ã‚Œã€æ¬¡ã®é€ä¿¡ãŒã§ãã‚‹ã‚ˆã†ã«ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã€‚

## ãƒ»ãƒãƒ¼ãƒˆã®ç›£è¦–

### â‘  **ç›£è¦–ã®å‘¨æœŸï¼ˆãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”ï¼‰ã‚’æ±ºã‚ã‚‹**

```C#
`_pollInterval = (pollInterval is { } t && t > TimeSpan.Zero) ? t : TimeSpan.FromSeconds(2);`
```

- `pollInterval` ã¯ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã€‚å¤–ã‹ã‚‰ã€Œä½•ç§’ãŠãã«ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã‹ã€ã‚’æ¸¡ã›ã‚‹ã‚ˆã†ã«ãªã£ã¦ã‚‹ã€‚
    
- ã§ã‚‚æ¸¡ã•ã‚Œãªã„å ´åˆï¼ˆ`null`ï¼‰ã‚„ã€0ä»¥ä¸‹ã®å€¤ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã¯**å®‰å…¨ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ**ã¨ã—ã¦2ç§’ã‚’ä½¿ã†ã€‚
    

ä¸­èº«ã‚’å™›ã¿ç •ãã¨ã“ã†ï¼š
```C#
if (pollInterval is { } t && t > TimeSpan.Zero)
_pollInterval = t; // æœ‰åŠ¹ãªå€¤ãŒæ¸¡ã•ã‚ŒãŸ â†’ ãã‚Œã‚’ä½¿ã†
else     
_pollInterval = TimeSpan.FromSeconds(2); // ç„¡åŠ¹ or null â†’ 2ç§’å‘¨æœŸ
````

ã“ã“ã§ä½¿ã‚ã‚Œã¦ã‚‹æ§‹æ–‡ï¼š

- `pollInterval is { } t` ã¯ã€Œnullã˜ã‚ƒãªã‘ã‚Œã° t ã«ä»£å…¥ã€ã¨ã„ã†**ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒæ§‹æ–‡**ã€‚
    
- `&& t > TimeSpan.Zero` ã¯ã€Œã—ã‹ã‚‚0ã‚ˆã‚Šå¤§ãã„ã‹ï¼Ÿã€ã¨ã„ã†ãƒã‚§ãƒƒã‚¯ã€‚
    

---

### â‘¡ **ã‚¿ã‚¤ãƒãƒ¼ã‚’èµ·å‹•**ã—ã¦ã€ã€Œå®šæœŸçš„ã«ãƒãƒ¼ãƒˆä¸€è¦§ã‚’å†å–å¾—ã™ã‚‹ã€

```C#
_timer = new System.Threading.Timer(OnTimer, null, _pollInterval, _pollInterval);
```

è§£èª¬ï¼š

- `System.Threading.Timer` ã¯ã€Œä¸€å®šé–“éš”ã§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã€ã‚¿ã‚¤ãƒãƒ¼ã€‚
    
- ç¬¬ä¸€å¼•æ•° `OnTimer` ã¯**ã‚¿ã‚¤ãƒãƒ¼ãŒé³´ã‚‹ãŸã³ã«å®Ÿè¡Œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰**ï¼ˆã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ã€‚
    
- ç¬¬äºŒå¼•æ•° `null` ã¯ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«æ¸¡ã™è¿½åŠ ãƒ‡ãƒ¼ã‚¿ï¼ˆä»Šå›ã¯ä¸è¦ã ã‹ã‚‰nullï¼‰ã€‚
    
- ç¬¬ä¸‰å¼•æ•° `_pollInterval` ã¯**æœ€åˆã®å‘¼ã³å‡ºã—ã¾ã§ã®å¾…ã¡æ™‚é–“**ã€‚
    
- ç¬¬å››å¼•æ•° `_pollInterval` ã¯**ç¹°ã‚Šè¿”ã—ã®é–“éš”**ã€‚
    

ã¤ã¾ã‚Šã“ã®1è¡Œã§ï¼š

> â€œãƒ—ãƒ­ã‚°ãƒ©ãƒ èµ·å‹•å¾Œ `_pollInterval` ç§’ã”ã¨ã« OnTimer() ãŒå‘¼ã°ã‚Œã‚‹â€  
> ã¨ã„ã†è‡ªå‹•ç›£è¦–ãƒ«ãƒ¼ãƒ—ã‚’ã‚»ãƒƒãƒˆã—ã¦ã„ã‚‹ã€‚

---

### â‘¢ **æœ€åˆã®1å›ã ã‘ã€æ‰‹å‹•ã§ãƒãƒ¼ãƒˆä¸€è¦§ã‚’èª­ã¿å–ã‚‹**

```C#
_ = RefreshAsync(CancellationToken.None);
```

- `_ = ...` ã¯ã€Œæˆ»ã‚Šå€¤ã‚’ä½¿ã‚ãªã„ã€ã¨ã„ã†æ„å‘³ã€‚
    
    - `RefreshAsync()` ã¯ `Task` ã‚’è¿”ã™ã‘ã©ã€ã“ã“ã§ã¯çµæœã‚’å¾…ãŸãšã«â€œç«ã‚’ã¤ã‘ã‚‹ã ã‘â€ã€‚
        
- `CancellationToken.None` ã¯ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œãªã„ãƒˆãƒ¼ã‚¯ãƒ³ã€ã€‚  
    ã¤ã¾ã‚Šâ€œæ™®é€šã«æœ€å¾Œã¾ã§ã‚„ã£ã¦OKâ€ã¨ã„ã†æŒ‡å®šã€‚
    
ä¸­èº«ã® `RefreshAsync()` ã¯ï¼š
```C#
public Task RefreshAsync(...) {     
	latest = SerialPort.GetPortNames();     
	æ¯”è¼ƒã—ã¦å¤‰åŒ–ãŒã‚ã‚Œã° PortsChanged ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«; 
}
```

ã ã‹ã‚‰ã€**ã‚¢ãƒ—ãƒªèµ·å‹•ç›´å¾Œã«ä¸€åº¦ã ã‘æœ€æ–°ã®ãƒãƒ¼ãƒˆä¸€è¦§ã‚’å–å¾—**ã—ã¦ã€  
åˆæœŸçŠ¶æ…‹ã‚’æ•´ãˆã¦ã„ã‚‹ã‚ã‘ã€‚

### ãƒãƒ¼ãƒˆä¸€è¦§ã®å–å¾—ã¨æ¯”è¼ƒ
```C#
 public Task RefreshAsync(CancellationToken cancellationToken = default)
 {
     cancellationToken.ThrowIfCancellationRequested();
     string[] latest;
     try
     {
         latest = SerialPort.GetPortNames()
             .OrderBy(p => p, StringComparer.OrdinalIgnoreCase)
             .ToArray();
     }
     catch
     {
         // å–å¾—ã«å¤±æ•—ã—ãŸå ´åˆã¯ç„¡è¦–ï¼ˆãƒ‡ã‚¶ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‚„æ¨©é™ä¸è¶³ç­‰ï¼‰
         latest = Array.Empty<string>();
     }

     bool changed = false;
     lock (_gate)
     {
         if (!_ports.SequenceEqual(latest, StringComparer.OrdinalIgnoreCase))
         {
             _ports = latest;
             changed = true;
         }
     }

     if (changed)
     {
         PortsChanged?.Invoke(this, GetCurrentPorts());
     }

     return Task.CompletedTask;
 }
```

ã“ã“ã§ã‚„ã£ã¦ã‚‹ã®ã¯ï¼š

1. OSã‹ã‚‰ç¾åœ¨ã®ãƒãƒ¼ãƒˆåä¸€è¦§ã‚’å–å¾—ï¼ˆ`SerialPort.GetPortNames()`ï¼‰
    
2. ã‚½ãƒ¼ãƒˆã—ã¦ç¢ºå®šé †åºã‚’ã¤ã‘ã‚‹
	
3. ã‚‚ã—å–å¾—ã«å¤±æ•—ã—ãŸï¼ˆãƒ‡ã‚¶ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ãªã©ï¼‰ã‚‰ç©ºé…åˆ—ã«ã™ã‚‹
	
4. `_ports` ã«ä¿å­˜ã—ã¦ãŠã„ãŸå‰å›çµæœã¨æ–°ã—ã„ `latest` ã‚’æ¯”è¼ƒã€‚
	
5.  é•ã„ãŒã‚ã£ãŸã‚‰ `_ports` ã‚’æ›´æ–°ã—ã€ã‚¤ãƒ™ãƒ³ãƒˆ `PortsChanged` ã‚’ç™ºç«ã€‚
	
6. ä¸Šä½ï¼ˆãŸã¨ãˆã°UIã®COMãƒãƒ¼ãƒˆé¸æŠãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼‰ãŒã“ã“ã‚’è³¼èª­ã—ã¦ã„ã‚Œã°ã€è‡ªå‹•çš„ã«æ›´æ–°ã§ãã‚‹ã€‚
### ğŸ”¹ ã‚¿ã‚¤ãƒãƒ¼ã®å‡¦ç†ã¨ç ´æ£„

```C#
`private void OnTimer(object? state) {
	if (_disposed) return;     
	try { _ = RefreshAsync(CancellationToken.None); }
	catch { /* ç„¡è¦– */ } 
}
public void Dispose() {
	if (_disposed) return;
	_disposed = true;
	_timer.Dispose(); 
}`
```

- `_timer` ãŒå®šæœŸçš„ã« `OnTimer()` ã‚’å‘¼ã¶ã€‚
    
- `Dispose()` ãŒå‘¼ã°ã‚Œã‚‹ã¨ `_timer` ã‚’æ­¢ã‚ã¦çµ‚äº†ã€‚
    
- `IDisposable` å®Ÿè£…ã§ã‚¿ã‚¤ãƒãƒ¼ã‚’å®‰å…¨ã«è§£æ”¾ã€‚


## é€ä¿¡

### ã‚³ãƒãƒ³ãƒ‰ãƒ•ãƒ¬ãƒ¼ãƒ é€ä¿¡
### æ–‡å­—åˆ—é€ä¿¡

```C#
//æ”¹è¡Œãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ç¢ºèªã€‚
string payload = request.AppendLineFeed ? request.Payload + "\r\n" : request.Payload;

byte[] payloadBytes;
try
{
    payloadBytes = encoding.GetBytes(payload);
}
catch (EncoderFallbackException ex)
{
    TimeSpan failureDuration = _clock.UtcNow - startedAt;
    return StringSendResult.CreateFailure(
        failureDuration,
        "æŒ‡å®šã—ãŸæ–‡å­—åˆ—ã‚’é¸æŠã—ãŸæ–‡å­—ã‚³ãƒ¼ãƒ‰ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã§ã—ãŸ: " + ex.Message);
}

await _serialPort.WriteAsync(payloadBytes, cancellationToken).ConfigureAwait(false);
```

## ğŸ§  æ„å‘³ã‚’åˆ†è§£ã™ã‚‹ã¨

1. **`request.Payload`**  
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒUIï¼ˆ`StringSendTabControl`ï¼‰ã®ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã«å…¥åŠ›ã—ãŸæ–‡å­—åˆ—ã€‚  
    ä¾‹: `"HELLO"` ã¾ãŸã¯ `"AT+INFO"` ãªã©ã€‚
    
2. **`AppendLineFeed`**  
    ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒONãªã‚‰ã€æ”¹è¡Œã‚’æœ«å°¾ã«ä»˜ã‘ã‚‹ã€‚  
    â†’ `"HELLO\r\n"`
    
3. **`encoding.GetBytes(payload)`**  
    æŒ‡å®šã•ã‚ŒãŸæ–‡å­—ã‚³ãƒ¼ãƒ‰ï¼ˆUTF-8 / Shift_JIS ãªã©ï¼‰ã§æ–‡å­—åˆ—ã‚’**ãƒã‚¤ãƒˆåˆ—ã«å¤‰æ›**ã™ã‚‹ã€‚  
    ã“ã‚ŒãŒ `payloadBytes`ã€‚
    
    ä¾‹ãˆã°ï¼š
    
    |payload|Encoding|payloadBytes ã®å†…å®¹ï¼ˆ16é€²è¡¨ç¤ºï¼‰|
    |---|---|---|
    |`"HELLO"`|UTF-8|`48 45 4C 4C 4F`|
    |`"ã“ã‚“ã«ã¡ã¯"`|UTF-8|`E3 81 93 E3 82 93 E3 81 AB E3 81 A1 E3 81 AF`|
    |`"HELLO"`|Shift_JIS|`48 45 4C 4C 4F`ï¼ˆåŒã˜ï¼‰|
    |`"ãƒ†ã‚¹ãƒˆ"`|Shift_JIS|`83 65 83 58 83 67`|
    
    æ–‡å­—ã‚³ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹ãƒã‚¤ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé•ã†ã€‚  
    æ©Ÿå™¨å´ãŒã©ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ã‚’æœŸå¾…ã—ã¦ã„ã‚‹ã‹ã«åˆã‚ã›ã‚‹ã€‚
    
4. **`await _serialPort.WriteAsync(payloadBytes, cancellationToken)`**  
    ãã®ãƒã‚¤ãƒˆé…åˆ—ã‚’ã€ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã«éåŒæœŸã§æ›¸ãè¾¼ã‚€ã€‚  
    å®Ÿéš›ã«é€ä¿¡ç·šï¼ˆTXï¼‰ã«æµã‚Œã‚‹ã®ã¯ã“ã® `payloadBytes` ã®å†…å®¹ã€‚