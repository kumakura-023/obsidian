---
created: 2025-11-10T14:58
updated: 2025-11-10T15:21
---

## ・ポートを開く
```C#
MainForm.cs内
//ボタンをクリックすると、"非同期"でイベントが発生
_openPortButton.Click += async (_, _) => await InvokeSafelyAsync(_viewModel.OpenPortAsync);


	await _connectionGate.WaitAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
	try
	{
		cancellationToken.ThrowIfCancellationRequested();
		SetConnectionState(PortConnectionState.Opening);
		try
		{
			if (_serialPort.IsOpen)
			{
				if (!string.Equals(settings.PortName, _serialPort.CurrentSettings?.PortName, StringComparison.OrdinalIgnoreCase))
				{
					_serialPort.Close();
					_serialPort.Open(settings);
				}
				else
				{
					_serialPort.UpdateSettings(settings);
				}
			}
			else
			{
				_serialPort.Open(settings);
			}
			SetConnectionState(PortConnectionState.Open);
			StatusMessage = "ポート " + settings.PortName + " を開きました。";
			return true;
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			SetConnectionState(PortConnectionState.Faulted);
			StatusMessage = "ポートを開く際にエラーが発生しました: " + ex2.Message;
			return false;
		}
	}
	finally
	{
		_connectionGate.Release();
	}
}
```

`ConfigureAwait(false)` をつけると：

>「await のあとに、**元のスレッド（UIスレッド）に戻らず、スレッドプールのどこかで続きの処理をしていい**」
### 👀 つまり何のために使うか

### 1. **UIスレッドに戻る必要がないバックエンド処理**

たとえばポートを開く、ファイルを読む、CRCを計算するなど、  
UIと関係ない部分は `ConfigureAwait(false)` を付けると効率がいい。

理由：

- 戻るために `SynchronizationContext` のキャプチャ・復元が不要（わずかなコスト減）
    
- サーバー／非UI環境では、UIスレッドがないため戻ろうとしても無駄